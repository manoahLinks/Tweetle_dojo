// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
#include "controller.hpp"

#include "UniffiJsiTypes.h"
#include <stdexcept>
#include <map>
#include <utility>
#include <iostream>
#include <thread>

namespace react = facebook::react;
namespace jsi = facebook::jsi;

// Calling into Rust.
extern "C" {
    typedef void
    (*UniffiRustFutureContinuationCallback)(
    uint64_t data, 
    int8_t poll_result
    );
    typedef void
    (*UniffiForeignFutureDroppedCallback)(
    uint64_t handle
    );
    typedef void
    (*UniffiCallbackInterfaceFree)(
    uint64_t handle
    );
    typedef uint64_t
    (*UniffiCallbackInterfaceClone)(
    uint64_t handle
    );typedef struct UniffiForeignFutureDroppedCallbackStruct {
        uint64_t handle;
        UniffiForeignFutureDroppedCallback free;
    } UniffiForeignFutureDroppedCallbackStruct;typedef struct UniffiForeignFutureResultU8 {
        uint8_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultU8;
    typedef void
    (*UniffiForeignFutureCompleteU8)(
    uint64_t callback_data, 
    UniffiForeignFutureResultU8 result
    );typedef struct UniffiForeignFutureResultI8 {
        int8_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultI8;
    typedef void
    (*UniffiForeignFutureCompleteI8)(
    uint64_t callback_data, 
    UniffiForeignFutureResultI8 result
    );typedef struct UniffiForeignFutureResultU16 {
        uint16_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultU16;
    typedef void
    (*UniffiForeignFutureCompleteU16)(
    uint64_t callback_data, 
    UniffiForeignFutureResultU16 result
    );typedef struct UniffiForeignFutureResultI16 {
        int16_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultI16;
    typedef void
    (*UniffiForeignFutureCompleteI16)(
    uint64_t callback_data, 
    UniffiForeignFutureResultI16 result
    );typedef struct UniffiForeignFutureResultU32 {
        uint32_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultU32;
    typedef void
    (*UniffiForeignFutureCompleteU32)(
    uint64_t callback_data, 
    UniffiForeignFutureResultU32 result
    );typedef struct UniffiForeignFutureResultI32 {
        int32_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultI32;
    typedef void
    (*UniffiForeignFutureCompleteI32)(
    uint64_t callback_data, 
    UniffiForeignFutureResultI32 result
    );typedef struct UniffiForeignFutureResultU64 {
        uint64_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultU64;
    typedef void
    (*UniffiForeignFutureCompleteU64)(
    uint64_t callback_data, 
    UniffiForeignFutureResultU64 result
    );typedef struct UniffiForeignFutureResultI64 {
        int64_t return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultI64;
    typedef void
    (*UniffiForeignFutureCompleteI64)(
    uint64_t callback_data, 
    UniffiForeignFutureResultI64 result
    );typedef struct UniffiForeignFutureResultF32 {
        float return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultF32;
    typedef void
    (*UniffiForeignFutureCompleteF32)(
    uint64_t callback_data, 
    UniffiForeignFutureResultF32 result
    );typedef struct UniffiForeignFutureResultF64 {
        double return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultF64;
    typedef void
    (*UniffiForeignFutureCompleteF64)(
    uint64_t callback_data, 
    UniffiForeignFutureResultF64 result
    );typedef struct UniffiForeignFutureResultRustBuffer {
        RustBuffer return_value;
        RustCallStatus call_status;
    } UniffiForeignFutureResultRustBuffer;
    typedef void
    (*UniffiForeignFutureCompleteRustBuffer)(
    uint64_t callback_data, 
    UniffiForeignFutureResultRustBuffer result
    );typedef struct UniffiForeignFutureResultVoid {
        RustCallStatus call_status;
    } UniffiForeignFutureResultVoid;
    typedef void
    (*UniffiForeignFutureCompleteVoid)(
    uint64_t callback_data, 
    UniffiForeignFutureResultVoid result
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_clone_controlleraccount(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_free_controlleraccount(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage(
        RustBuffer app_id, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_constructor_controlleraccount_new(
        RustBuffer app_id, 
        RustBuffer username, 
        RustBuffer class_hash, 
        RustBuffer rpc_url, 
        /*handle*/ uint64_t owner, 
        RustBuffer address, 
        RustBuffer chain_id, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless(
        RustBuffer app_id, 
        RustBuffer username, 
        RustBuffer class_hash, 
        RustBuffer rpc_url, 
        /*handle*/ uint64_t owner, 
        RustBuffer chain_id, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_address(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_app_id(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_chain_id(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_method_controlleraccount_disconnect(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_error_message(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_execute(
        /*handle*/ uint64_t ptr, 
        RustBuffer calls, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_method_controlleraccount_signup(
        /*handle*/ uint64_t ptr, 
        RustBuffer signer_type, 
        RustBuffer session_expiration, 
        RustBuffer cartridge_api_url, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain(
        /*handle*/ uint64_t ptr, 
        RustBuffer rpc_url, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_transfer(
        /*handle*/ uint64_t ptr, 
        RustBuffer recipient, 
        RustBuffer amount, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_controlleraccount_username(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_clone_owner(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_free_owner(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_constructor_owner_new(
        RustBuffer private_key, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_clone_sessionaccount(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void uniffi_controller_uniffi_fn_free_sessionaccount(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe(
        RustBuffer private_key, 
        RustBuffer policies, 
        RustBuffer rpc_url, 
        RustBuffer cartridge_api_url, 
        RustCallStatus *uniffi_out_err
    );
    /*handle*/ uint64_t uniffi_controller_uniffi_fn_constructor_sessionaccount_new(
        RustBuffer rpc_url, 
        RustBuffer private_key, 
        RustBuffer address, 
        RustBuffer owner_guid, 
        RustBuffer chain_id, 
        RustBuffer policies, 
        uint64_t session_expiration, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_address(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_app_id(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_chain_id(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_execute(
        /*handle*/ uint64_t ptr, 
        RustBuffer calls, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside(
        /*handle*/ uint64_t ptr, 
        RustBuffer calls, 
        RustCallStatus *uniffi_out_err
    );
    uint64_t uniffi_controller_uniffi_fn_method_sessionaccount_expires_at(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    int8_t uniffi_controller_uniffi_fn_method_sessionaccount_is_expired(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    int8_t uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_session_id(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_method_sessionaccount_username(
        /*handle*/ uint64_t ptr, 
        RustCallStatus *uniffi_out_err
    );
    int8_t uniffi_controller_uniffi_fn_func_controller_has_storage(
        RustBuffer app_id, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_func_get_controller_class_hash(
        RustBuffer version, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_func_get_public_key(
        RustBuffer private_key, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer uniffi_controller_uniffi_fn_func_signer_to_guid(
        RustBuffer private_key, 
        RustCallStatus *uniffi_out_err
    );
    int8_t uniffi_controller_uniffi_fn_func_validate_felt(
        RustBuffer felt, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer ffi_controller_uniffi_rustbuffer_alloc(
        uint64_t size, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer ffi_controller_uniffi_rustbuffer_from_bytes(
        ForeignBytes bytes, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rustbuffer_free(
        RustBuffer buf, 
        RustCallStatus *uniffi_out_err
    );
    RustBuffer ffi_controller_uniffi_rustbuffer_reserve(
        RustBuffer buf, 
        uint64_t additional, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_u8(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_u8(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_u8(
        /*handle*/ uint64_t handle
    );
    uint8_t ffi_controller_uniffi_rust_future_complete_u8(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_i8(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_i8(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_i8(
        /*handle*/ uint64_t handle
    );
    int8_t ffi_controller_uniffi_rust_future_complete_i8(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_u16(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_u16(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_u16(
        /*handle*/ uint64_t handle
    );
    uint16_t ffi_controller_uniffi_rust_future_complete_u16(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_i16(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_i16(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_i16(
        /*handle*/ uint64_t handle
    );
    int16_t ffi_controller_uniffi_rust_future_complete_i16(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_u32(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_u32(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_u32(
        /*handle*/ uint64_t handle
    );
    uint32_t ffi_controller_uniffi_rust_future_complete_u32(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_i32(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_i32(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_i32(
        /*handle*/ uint64_t handle
    );
    int32_t ffi_controller_uniffi_rust_future_complete_i32(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_u64(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_u64(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_u64(
        /*handle*/ uint64_t handle
    );
    uint64_t ffi_controller_uniffi_rust_future_complete_u64(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_i64(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_i64(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_i64(
        /*handle*/ uint64_t handle
    );
    int64_t ffi_controller_uniffi_rust_future_complete_i64(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_f32(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_f32(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_f32(
        /*handle*/ uint64_t handle
    );
    float ffi_controller_uniffi_rust_future_complete_f32(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_f64(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_f64(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_f64(
        /*handle*/ uint64_t handle
    );
    double ffi_controller_uniffi_rust_future_complete_f64(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_rust_buffer(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_rust_buffer(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_rust_buffer(
        /*handle*/ uint64_t handle
    );
    RustBuffer ffi_controller_uniffi_rust_future_complete_rust_buffer(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    void ffi_controller_uniffi_rust_future_poll_void(
        /*handle*/ uint64_t handle, 
        UniffiRustFutureContinuationCallback callback, 
        /*handle*/ uint64_t callback_data
    );
    void ffi_controller_uniffi_rust_future_cancel_void(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_free_void(
        /*handle*/ uint64_t handle
    );
    void ffi_controller_uniffi_rust_future_complete_void(
        /*handle*/ uint64_t handle, 
        RustCallStatus *uniffi_out_err
    );
    uint16_t uniffi_controller_uniffi_checksum_func_controller_has_storage(
    );
    uint16_t uniffi_controller_uniffi_checksum_func_get_controller_class_hash(
    );
    uint16_t uniffi_controller_uniffi_checksum_func_get_public_key(
    );
    uint16_t uniffi_controller_uniffi_checksum_func_signer_to_guid(
    );
    uint16_t uniffi_controller_uniffi_checksum_func_validate_felt(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_address(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_app_id(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_error_message(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_execute(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_signup(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_transfer(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_controlleraccount_username(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_address(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_app_id(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_execute(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_session_id(
    );
    uint16_t uniffi_controller_uniffi_checksum_method_sessionaccount_username(
    );
    uint16_t uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage(
    );
    uint16_t uniffi_controller_uniffi_checksum_constructor_controlleraccount_new(
    );
    uint16_t uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless(
    );
    uint16_t uniffi_controller_uniffi_checksum_constructor_owner_new(
    );
    uint16_t uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe(
    );
    uint16_t uniffi_controller_uniffi_checksum_constructor_sessionaccount_new(
    );
    uint32_t ffi_controller_uniffi_uniffi_contract_version(
    );
}


namespace uniffi::controller {
template <typename T> struct Bridging;

using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <typename T> struct Bridging<ReferenceHolder<T>> {
  static jsi::Value jsNew(jsi::Runtime &rt) {
    auto holder = jsi::Object(rt);
    return holder;
  }
  static T fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
                  const jsi::Value &value) {
    auto obj = value.asObject(rt);
    if (obj.hasProperty(rt, "pointee")) {
      auto pointee = obj.getProperty(rt, "pointee");
      return uniffi::controller::Bridging<T>::fromJs(rt, callInvoker, pointee);
    }
    throw jsi::JSError(
      rt,
      "Expected ReferenceHolder to have a pointee property. This is likely a bug in uniffi-bindgen-react-native"
    );
  }
};
} // namespace uniffi::controller
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustBuffer> {
  static RustBuffer rustbuffer_alloc(int32_t size) {
      RustCallStatus status = { UNIFFI_CALL_STATUS_OK };
      return ffi_controller_uniffi_rustbuffer_alloc(
          size,
          &status
      );
  }

  static void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = { UNIFFI_CALL_STATUS_OK };
    ffi_controller_uniffi_rustbuffer_free(
        buf,
        &status
    );
  }

  static RustBuffer rustbuffer_from_bytes(ForeignBytes bytes) {
    RustCallStatus status = { UNIFFI_CALL_STATUS_OK };
    return ffi_controller_uniffi_rustbuffer_from_bytes(
      bytes,
      &status
    );
  }

  static RustBuffer fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                           const jsi::Value &value) {
    try {
      auto buffer = uniffi_jsi::Bridging<jsi::ArrayBuffer>::value_to_arraybuffer(rt, value);
      auto bytes = ForeignBytes{
          .len = static_cast<int32_t>(buffer.length(rt)),
          .data = buffer.data(rt),
      };

      // This buffer is constructed from foreign bytes. Rust scaffolding copies
      // the bytes, to make the RustBuffer.
      auto buf = rustbuffer_from_bytes(bytes);
      // Once it leaves this function, the buffer is immediately passed back
      // into Rust, where it's used to deserialize into the Rust versions of the
      // arguments. At that point, the copy is destroyed.
      return buf;
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                         RustBuffer buf) {
    // We need to make a copy of the bytes from Rust's memory space into
    // Javascripts memory space. We need to do this because the two languages
    // manages memory very differently: a garbage collector needs to track all
    // the memory at runtime, Rust is doing it all closer to compile time.
    uint8_t *bytes = new uint8_t[buf.len];
    std::memcpy(bytes, buf.data, buf.len);

    // Construct an ArrayBuffer with copy of the bytes from the RustBuffer.
    auto payload = std::make_shared<uniffi_jsi::CMutableBuffer>(
        uniffi_jsi::CMutableBuffer((uint8_t *)bytes, buf.len));
    auto arrayBuffer = jsi::ArrayBuffer(rt, payload);

    // Once we have a Javascript version, we no longer need the Rust version, so
    // we can call into Rust to tell it it's okay to free that memory.
    rustbuffer_free(buf);

    // Finally, return the ArrayBuffer.
    return uniffi_jsi::Bridging<jsi::ArrayBuffer>::arraybuffer_to_value(rt, arrayBuffer);;
  }
};

} // namespace uniffi::controller

namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustCallStatus> {
  static jsi::Value jsSuccess(jsi::Runtime &rt) {
    auto statusObject = jsi::Object(rt);
    statusObject.setProperty(rt, "code", jsi::Value(rt, UNIFFI_CALL_STATUS_OK));
    return statusObject;
  }
  static RustCallStatus rustSuccess(jsi::Runtime &rt) {
    return {UNIFFI_CALL_STATUS_OK};
  }
  static void copyIntoJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         const RustCallStatus status,
                         const jsi::Value &jsStatus) {
    auto statusObject = jsStatus.asObject(rt);
    if (status.error_buf.data != nullptr) {
      auto rbuf = Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                         status.error_buf);
      statusObject.setProperty(rt, "errorBuf", rbuf);
    }
    if (status.code != UNIFFI_CALL_STATUS_OK) {
      auto code =
          uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, status.code);
      statusObject.setProperty(rt, "code", code);
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         const RustCallStatus &status) {
    auto statusObject = jsi::Object(rt);
    if (status.error_buf.data != nullptr) {
      auto rbuf = Bridging<RustBuffer>::toJs(rt, callInvoker, status.error_buf);
      statusObject.setProperty(rt, "errorBuf", rbuf);
    }
    statusObject.setProperty(rt, "code", uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, status.code));
    return statusObject;
  }

  static RustCallStatus fromJs(jsi::Runtime &rt,
                               std::shared_ptr<CallInvoker> invoker,
                               const jsi::Value &jsStatus) {
    RustCallStatus status;
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status.error_buf =
          Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status.code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
    return status;
  }

  static void copyFromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> invoker,
                         const jsi::Value &jsStatus, RustCallStatus *status) {
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status->error_buf =
          Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status->code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
  }
};

} // namespace uniffi::controller
// In other uniffi bindings, it is assumed that the foreign language holds on
// to the vtable, which the Rust just gets a pointer to.
// Here, we need to hold on to them, but also be able to clear them at just the
// right time so we can support hot-reloading.
namespace uniffi::controller::registry {
    template <typename T>
    class VTableHolder {
    public:
        T vtable;
        VTableHolder(T v) : vtable(v) {}
    };

    // Mutex to bind the storage and setting of vtable together.
    // We declare it here, but the lock is taken by callers of the putTable
    // method who are also sending a pointer to Rust.
    static std::mutex vtableMutex;

    // Registry to hold all vtables so they persist even when JS objects are GC'd.
    // The only reason this exists is to prevent a dangling pointer in the
    // Rust machinery: i.e. we don't need to access or write to this registry
    // after startup.
    // Registry to hold all vtables so they persist even when JS objects are GC'd.
    // Maps string identifiers to vtable holders using type erasure
    static std::unordered_map<std::string, std::shared_ptr<void>> vtableRegistry;

    // Add a vtable to the registry with an identifier
    template <typename T>
    static T* putTable(std::string_view identifier, T vtable) {
        auto holder = std::make_shared<VTableHolder<T>>(vtable);
        // Store the raw pointer to the vtable before type erasure
        T* rawPtr = &(holder->vtable);
        // Store the holder using type erasure with the string identifier
        vtableRegistry[std::string(identifier)] = std::shared_ptr<void>(holder);
        return rawPtr;
    }

    // Clear the registry.
    //
    // Conceptually, this is called after teardown of the module (i.e. after
    // teardown of the jsi::Runtime). However, because Rust is dropping callbacks
    // because the Runtime is being torn down, we must keep the registry intact
    // until after the runtime goes away.
    //
    // Therefore, in practice we should call this when the next runtime is
    // being stood up.
    static void clearRegistry() {
        std::lock_guard<std::mutex> lock(vtableMutex);
        vtableRegistry.clear();
    }
} // namespace uniffi::controller::registry

// This calls into Rust.

// Generate Bridging for ForeignFutureResult structs (needed if module doesn't have async fns)
// Generate Bridging templates for internal UniffiForeignFutureResult structs
// These are used by async callbacks but not exposed in ffi_definitions()
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

#ifndef BRIDGING_UniffiForeignFutureResultU8_DEFINED
#define BRIDGING_UniffiForeignFutureResultU8_DEFINED
template <> struct Bridging<UniffiForeignFutureResultU8> {
  static UniffiForeignFutureResultU8 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU8");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultU8 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU8 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultU8_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultI8_DEFINED
#define BRIDGING_UniffiForeignFutureResultI8_DEFINED
template <> struct Bridging<UniffiForeignFutureResultI8> {
  static UniffiForeignFutureResultI8 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI8");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultI8 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI8 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultI8_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultU16_DEFINED
#define BRIDGING_UniffiForeignFutureResultU16_DEFINED
template <> struct Bridging<UniffiForeignFutureResultU16> {
  static UniffiForeignFutureResultU16 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU16");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultU16 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU16 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultU16_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultI16_DEFINED
#define BRIDGING_UniffiForeignFutureResultI16_DEFINED
template <> struct Bridging<UniffiForeignFutureResultI16> {
  static UniffiForeignFutureResultI16 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI16");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultI16 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI16 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultI16_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultU32_DEFINED
#define BRIDGING_UniffiForeignFutureResultU32_DEFINED
template <> struct Bridging<UniffiForeignFutureResultU32> {
  static UniffiForeignFutureResultU32 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU32");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultU32 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU32 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultU32_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultI32_DEFINED
#define BRIDGING_UniffiForeignFutureResultI32_DEFINED
template <> struct Bridging<UniffiForeignFutureResultI32> {
  static UniffiForeignFutureResultI32 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI32");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultI32 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI32 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultI32_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultU64_DEFINED
#define BRIDGING_UniffiForeignFutureResultU64_DEFINED
template <> struct Bridging<UniffiForeignFutureResultU64> {
  static UniffiForeignFutureResultU64 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU64");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultU64 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU64 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultU64_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultI64_DEFINED
#define BRIDGING_UniffiForeignFutureResultI64_DEFINED
template <> struct Bridging<UniffiForeignFutureResultI64> {
  static UniffiForeignFutureResultI64 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI64");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultI64 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI64 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultI64_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultF32_DEFINED
#define BRIDGING_UniffiForeignFutureResultF32_DEFINED
template <> struct Bridging<UniffiForeignFutureResultF32> {
  static UniffiForeignFutureResultF32 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultF32");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultF32 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultF32 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultF32_DEFINED

#ifndef BRIDGING_UniffiForeignFutureResultF64_DEFINED
#define BRIDGING_UniffiForeignFutureResultF64_DEFINED
template <> struct Bridging<UniffiForeignFutureResultF64> {
  static UniffiForeignFutureResultF64 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultF64");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultF64 rsObject;
    
    // Convert return_value field
    rsObject.return_value = uniffi_jsi::Bridging<decltype(rsObject.return_value)>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultF64 &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      uniffi_jsi::Bridging<decltype(rsValue.return_value)>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultF64_DEFINED

// Special case for Void - no return_value field
#ifndef BRIDGING_UniffiForeignFutureResultVoid_DEFINED
#define BRIDGING_UniffiForeignFutureResultVoid_DEFINED
template <> struct Bridging<UniffiForeignFutureResultVoid> {
  static UniffiForeignFutureResultVoid fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultVoid");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultVoid rsObject;
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultVoid &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultVoid_DEFINED

// Special case for RustBuffer - uses module namespace Bridging, not uniffi_jsi
#ifndef BRIDGING_UniffiForeignFutureResultRustBuffer_DEFINED
#define BRIDGING_UniffiForeignFutureResultRustBuffer_DEFINED
template <> struct Bridging<UniffiForeignFutureResultRustBuffer> {
  static UniffiForeignFutureResultRustBuffer fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultRustBuffer");
    }
    auto jsObject = jsValue.getObject(rt);
    UniffiForeignFutureResultRustBuffer rsObject;
    
    // Convert return_value field - RustBuffer uses module namespace Bridging
    rsObject.return_value = Bridging<RustBuffer>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "return_value")
    );
    
    // Convert call_status field 
    rsObject.call_status = Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "call_status")
    );
    
    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultRustBuffer &rsValue
  ) {
    auto jsObject = jsi::Object(rt);
    
    jsObject.setProperty(rt, "return_value",
      Bridging<RustBuffer>::toJs(rt, callInvoker, rsValue.return_value)
    );
    
    jsObject.setProperty(rt, "call_status",
      Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );
    
    return jsObject;
  }
};
#endif // BRIDGING_UniffiForeignFutureResultRustBuffer_DEFINED

} // namespace uniffi::controller


// FIRST: Declare all callback wrapper structs
#ifndef WRAPPER_DECL_UniffiRustFutureContinuationCallback_DEFINED
#define WRAPPER_DECL_UniffiRustFutureContinuationCallback_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiRustFutureContinuationCallbackWrapper {
    UniffiRustFutureContinuationCallback callback;
    explicit UniffiRustFutureContinuationCallbackWrapper(UniffiRustFutureContinuationCallback cb) : callback(cb) {}
    operator UniffiRustFutureContinuationCallback() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiRustFutureContinuationCallback_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureDroppedCallback_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureDroppedCallback_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureDroppedCallbackWrapper {
    UniffiForeignFutureDroppedCallback callback;
    explicit UniffiForeignFutureDroppedCallbackWrapper(UniffiForeignFutureDroppedCallback cb) : callback(cb) {}
    operator UniffiForeignFutureDroppedCallback() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureDroppedCallback_DEFINED


#ifndef WRAPPER_DECL_UniffiCallbackInterfaceFree_DEFINED
#define WRAPPER_DECL_UniffiCallbackInterfaceFree_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiCallbackInterfaceFreeWrapper {
    UniffiCallbackInterfaceFree callback;
    explicit UniffiCallbackInterfaceFreeWrapper(UniffiCallbackInterfaceFree cb) : callback(cb) {}
    operator UniffiCallbackInterfaceFree() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiCallbackInterfaceFree_DEFINED


#ifndef WRAPPER_DECL_UniffiCallbackInterfaceClone_DEFINED
#define WRAPPER_DECL_UniffiCallbackInterfaceClone_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiCallbackInterfaceCloneWrapper {
    UniffiCallbackInterfaceClone callback;
    explicit UniffiCallbackInterfaceCloneWrapper(UniffiCallbackInterfaceClone cb) : callback(cb) {}
    operator UniffiCallbackInterfaceClone() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiCallbackInterfaceClone_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteU8_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteU8_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteU8Wrapper {
    UniffiForeignFutureCompleteU8 callback;
    explicit UniffiForeignFutureCompleteU8Wrapper(UniffiForeignFutureCompleteU8 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteU8() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteU8_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteI8_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteI8_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteI8Wrapper {
    UniffiForeignFutureCompleteI8 callback;
    explicit UniffiForeignFutureCompleteI8Wrapper(UniffiForeignFutureCompleteI8 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteI8() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteI8_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteU16_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteU16_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteU16Wrapper {
    UniffiForeignFutureCompleteU16 callback;
    explicit UniffiForeignFutureCompleteU16Wrapper(UniffiForeignFutureCompleteU16 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteU16() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteU16_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteI16_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteI16_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteI16Wrapper {
    UniffiForeignFutureCompleteI16 callback;
    explicit UniffiForeignFutureCompleteI16Wrapper(UniffiForeignFutureCompleteI16 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteI16() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteI16_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteU32_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteU32_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteU32Wrapper {
    UniffiForeignFutureCompleteU32 callback;
    explicit UniffiForeignFutureCompleteU32Wrapper(UniffiForeignFutureCompleteU32 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteU32() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteU32_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteI32_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteI32_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteI32Wrapper {
    UniffiForeignFutureCompleteI32 callback;
    explicit UniffiForeignFutureCompleteI32Wrapper(UniffiForeignFutureCompleteI32 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteI32() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteI32_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteU64_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteU64_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteU64Wrapper {
    UniffiForeignFutureCompleteU64 callback;
    explicit UniffiForeignFutureCompleteU64Wrapper(UniffiForeignFutureCompleteU64 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteU64() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteU64_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteI64_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteI64_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteI64Wrapper {
    UniffiForeignFutureCompleteI64 callback;
    explicit UniffiForeignFutureCompleteI64Wrapper(UniffiForeignFutureCompleteI64 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteI64() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteI64_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteF32_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteF32_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteF32Wrapper {
    UniffiForeignFutureCompleteF32 callback;
    explicit UniffiForeignFutureCompleteF32Wrapper(UniffiForeignFutureCompleteF32 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteF32() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteF32_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteF64_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteF64_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteF64Wrapper {
    UniffiForeignFutureCompleteF64 callback;
    explicit UniffiForeignFutureCompleteF64Wrapper(UniffiForeignFutureCompleteF64 cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteF64() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteF64_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteRustBuffer_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteRustBuffer_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteRustBufferWrapper {
    UniffiForeignFutureCompleteRustBuffer callback;
    explicit UniffiForeignFutureCompleteRustBufferWrapper(UniffiForeignFutureCompleteRustBuffer cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteRustBuffer() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteRustBuffer_DEFINED


#ifndef WRAPPER_DECL_UniffiForeignFutureCompleteVoid_DEFINED
#define WRAPPER_DECL_UniffiForeignFutureCompleteVoid_DEFINED
namespace uniffi::controller {
// Forward declaration of wrapper struct
struct UniffiForeignFutureCompleteVoidWrapper {
    UniffiForeignFutureCompleteVoid callback;
    explicit UniffiForeignFutureCompleteVoidWrapper(UniffiForeignFutureCompleteVoid cb) : callback(cb) {}
    operator UniffiForeignFutureCompleteVoid() const { return callback; }
};
} // namespace uniffi::controller
#endif // WRAPPER_DECL_UniffiForeignFutureCompleteVoid_DEFINED



// SECOND: Generate callback implementations (makeCallbackFunction, etc.)
// Structs need these for their fromJs methods
#ifndef CALLBACK_uniffi_controller_cb_rustfuturecontinuationcallback_UniffiRustFutureContinuationCallback_DEFINED
#define CALLBACK_uniffi_controller_cb_rustfuturecontinuationcallback_UniffiRustFutureContinuationCallback_DEFINED
// Callback function: uniffi::controller::cb::rustfuturecontinuationcallback::UniffiRustFutureContinuationCallback
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::rustfuturecontinuationcallback {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, int8_t)> rsLambda_UniffiRustFutureContinuationCallback = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiRustFutureContinuationCallback(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_data
            ,int8_t rs_pollResult) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_data = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_data);
        auto js_pollResult = uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, rs_pollResult);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_data, js_pollResult
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiRustFutureContinuationCallback: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiRustFutureContinuationCallback(uint64_t rs_data, int8_t rs_pollResult) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiRustFutureContinuationCallback.
        //
        // If rsLamda_UniffiRustFutureContinuationCallback is null, then there is no runtime to call into.
        if (rsLambda_UniffiRustFutureContinuationCallback == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiRustFutureContinuationCallback(
            rs_data, 
            rs_pollResult);
    }

    [[maybe_unused]] static UniffiRustFutureContinuationCallback
    makeCallbackFunction( // uniffi::controller::cb::rustfuturecontinuationcallback
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiRustFutureContinuationCallback != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiRustFutureContinuationCallback;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiRustFutureContinuationCallback = [rtPtr, callInvoker, callbackValue](uint64_t rs_data, int8_t rs_pollResult) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_data
                    , rs_pollResult](jsi::Runtime &rt) mutable {
                    body_UniffiRustFutureContinuationCallback(rt, callInvoker, callbackValue
                        , rs_data
                        , rs_pollResult);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiRustFutureContinuationCallback;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiRustFutureContinuationCallback = nullptr;
    }
} // namespace uniffi::controller::cb::rustfuturecontinuationcallback
#endif // CALLBACK_uniffi_controller_cb_rustfuturecontinuationcallback_UniffiRustFutureContinuationCallback_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturedroppedcallback_UniffiForeignFutureDroppedCallback_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturedroppedcallback_UniffiForeignFutureDroppedCallback_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturedroppedcallback::UniffiForeignFutureDroppedCallback
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturedroppedcallback {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t)> rsLambda_UniffiForeignFutureDroppedCallback = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureDroppedCallback(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_handle) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_handle = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_handle
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureDroppedCallback: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureDroppedCallback(uint64_t rs_handle) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureDroppedCallback.
        //
        // If rsLamda_UniffiForeignFutureDroppedCallback is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureDroppedCallback == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureDroppedCallback(
            rs_handle);
    }

    [[maybe_unused]] static UniffiForeignFutureDroppedCallback
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturedroppedcallback
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureDroppedCallback != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureDroppedCallback;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureDroppedCallback = [rtPtr, callInvoker, callbackValue](uint64_t rs_handle) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_handle](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureDroppedCallback(rt, callInvoker, callbackValue
                        , rs_handle);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureDroppedCallback;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureDroppedCallback = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturedroppedcallback
#endif // CALLBACK_uniffi_controller_cb_foreignfuturedroppedcallback_UniffiForeignFutureDroppedCallback_DEFINED

#ifndef CALLBACK_uniffi_controller_cb_callbackinterfaceclone_UniffiCallbackInterfaceClone_DEFINED
#define CALLBACK_uniffi_controller_cb_callbackinterfaceclone_UniffiCallbackInterfaceClone_DEFINED
// Callback function: uniffi::controller::cb::callbackinterfaceclone::UniffiCallbackInterfaceClone
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::callbackinterfaceclone {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<uint64_t(uint64_t)> rsLambda_UniffiCallbackInterfaceClone = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiCallbackInterfaceClone(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_handle) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_handle = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_handle
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiCallbackInterfaceClone: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static uint64_t callback_UniffiCallbackInterfaceClone(uint64_t rs_handle) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiCallbackInterfaceClone.
        //
        // If rsLamda_UniffiCallbackInterfaceClone is null, then there is no runtime to call into.
        if (rsLambda_UniffiCallbackInterfaceClone == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return 0;  // Return zero for handle/uint64_t return types
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        return rsLambda_UniffiCallbackInterfaceClone(
            rs_handle);
    }

    [[maybe_unused]] static UniffiCallbackInterfaceClone
    makeCallbackFunction( // uniffi::controller::cb::callbackinterfaceclone
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiCallbackInterfaceClone != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiCallbackInterfaceClone;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiCallbackInterfaceClone = [rtPtr, callInvoker, callbackValue](uint64_t rs_handle) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_handle](jsi::Runtime &rt) mutable {
                    body_UniffiCallbackInterfaceClone(rt, callInvoker, callbackValue
                        , rs_handle);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
                return 0;  // Async callback, return immediately
        };
        return callback_UniffiCallbackInterfaceClone;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiCallbackInterfaceClone = nullptr;
    }
} // namespace uniffi::controller::cb::callbackinterfaceclone
#endif // CALLBACK_uniffi_controller_cb_callbackinterfaceclone_UniffiCallbackInterfaceClone_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompleteu8_UniffiForeignFutureCompleteU8_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompleteu8_UniffiForeignFutureCompleteU8_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompleteu8::UniffiForeignFutureCompleteU8
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompleteu8 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultU8)> rsLambda_UniffiForeignFutureCompleteU8 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteU8(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultU8 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultU8>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteU8: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteU8(uint64_t rs_callbackData, UniffiForeignFutureResultU8 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteU8.
        //
        // If rsLamda_UniffiForeignFutureCompleteU8 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteU8 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteU8(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteU8
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompleteu8
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteU8 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteU8;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteU8 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultU8 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteU8(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteU8;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteU8 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompleteu8
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompleteu8_UniffiForeignFutureCompleteU8_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletei8_UniffiForeignFutureCompleteI8_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletei8_UniffiForeignFutureCompleteI8_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletei8::UniffiForeignFutureCompleteI8
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletei8 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultI8)> rsLambda_UniffiForeignFutureCompleteI8 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteI8(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultI8 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultI8>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteI8: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteI8(uint64_t rs_callbackData, UniffiForeignFutureResultI8 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteI8.
        //
        // If rsLamda_UniffiForeignFutureCompleteI8 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteI8 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteI8(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteI8
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletei8
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteI8 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteI8;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteI8 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultI8 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteI8(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteI8;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteI8 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletei8
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletei8_UniffiForeignFutureCompleteI8_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompleteu16_UniffiForeignFutureCompleteU16_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompleteu16_UniffiForeignFutureCompleteU16_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompleteu16::UniffiForeignFutureCompleteU16
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompleteu16 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultU16)> rsLambda_UniffiForeignFutureCompleteU16 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteU16(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultU16 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultU16>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteU16: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteU16(uint64_t rs_callbackData, UniffiForeignFutureResultU16 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteU16.
        //
        // If rsLamda_UniffiForeignFutureCompleteU16 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteU16 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteU16(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteU16
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompleteu16
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteU16 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteU16;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteU16 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultU16 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteU16(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteU16;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteU16 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompleteu16
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompleteu16_UniffiForeignFutureCompleteU16_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletei16_UniffiForeignFutureCompleteI16_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletei16_UniffiForeignFutureCompleteI16_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletei16::UniffiForeignFutureCompleteI16
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletei16 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultI16)> rsLambda_UniffiForeignFutureCompleteI16 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteI16(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultI16 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultI16>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteI16: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteI16(uint64_t rs_callbackData, UniffiForeignFutureResultI16 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteI16.
        //
        // If rsLamda_UniffiForeignFutureCompleteI16 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteI16 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteI16(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteI16
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletei16
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteI16 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteI16;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteI16 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultI16 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteI16(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteI16;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteI16 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletei16
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletei16_UniffiForeignFutureCompleteI16_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompleteu32_UniffiForeignFutureCompleteU32_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompleteu32_UniffiForeignFutureCompleteU32_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompleteu32::UniffiForeignFutureCompleteU32
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompleteu32 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultU32)> rsLambda_UniffiForeignFutureCompleteU32 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteU32(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultU32 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultU32>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteU32: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteU32(uint64_t rs_callbackData, UniffiForeignFutureResultU32 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteU32.
        //
        // If rsLamda_UniffiForeignFutureCompleteU32 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteU32 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteU32(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteU32
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompleteu32
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteU32 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteU32;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteU32 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultU32 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteU32(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteU32;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteU32 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompleteu32
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompleteu32_UniffiForeignFutureCompleteU32_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletei32_UniffiForeignFutureCompleteI32_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletei32_UniffiForeignFutureCompleteI32_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletei32::UniffiForeignFutureCompleteI32
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletei32 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultI32)> rsLambda_UniffiForeignFutureCompleteI32 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteI32(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultI32 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultI32>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteI32: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteI32(uint64_t rs_callbackData, UniffiForeignFutureResultI32 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteI32.
        //
        // If rsLamda_UniffiForeignFutureCompleteI32 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteI32 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteI32(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteI32
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletei32
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteI32 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteI32;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteI32 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultI32 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteI32(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteI32;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteI32 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletei32
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletei32_UniffiForeignFutureCompleteI32_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompleteu64_UniffiForeignFutureCompleteU64_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompleteu64_UniffiForeignFutureCompleteU64_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompleteu64::UniffiForeignFutureCompleteU64
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompleteu64 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultU64)> rsLambda_UniffiForeignFutureCompleteU64 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteU64(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultU64 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultU64>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteU64: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteU64(uint64_t rs_callbackData, UniffiForeignFutureResultU64 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteU64.
        //
        // If rsLamda_UniffiForeignFutureCompleteU64 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteU64 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteU64(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteU64
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompleteu64
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteU64 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteU64;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteU64 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultU64 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteU64(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteU64;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteU64 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompleteu64
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompleteu64_UniffiForeignFutureCompleteU64_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletei64_UniffiForeignFutureCompleteI64_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletei64_UniffiForeignFutureCompleteI64_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletei64::UniffiForeignFutureCompleteI64
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletei64 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultI64)> rsLambda_UniffiForeignFutureCompleteI64 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteI64(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultI64 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultI64>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteI64: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteI64(uint64_t rs_callbackData, UniffiForeignFutureResultI64 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteI64.
        //
        // If rsLamda_UniffiForeignFutureCompleteI64 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteI64 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteI64(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteI64
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletei64
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteI64 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteI64;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteI64 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultI64 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteI64(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteI64;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteI64 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletei64
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletei64_UniffiForeignFutureCompleteI64_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletef32_UniffiForeignFutureCompleteF32_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletef32_UniffiForeignFutureCompleteF32_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletef32::UniffiForeignFutureCompleteF32
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletef32 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultF32)> rsLambda_UniffiForeignFutureCompleteF32 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteF32(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultF32 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultF32>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteF32: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteF32(uint64_t rs_callbackData, UniffiForeignFutureResultF32 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteF32.
        //
        // If rsLamda_UniffiForeignFutureCompleteF32 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteF32 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteF32(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteF32
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletef32
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteF32 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteF32;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteF32 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultF32 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteF32(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteF32;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteF32 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletef32
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletef32_UniffiForeignFutureCompleteF32_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletef64_UniffiForeignFutureCompleteF64_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletef64_UniffiForeignFutureCompleteF64_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletef64::UniffiForeignFutureCompleteF64
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletef64 {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultF64)> rsLambda_UniffiForeignFutureCompleteF64 = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteF64(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultF64 rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultF64>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteF64: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteF64(uint64_t rs_callbackData, UniffiForeignFutureResultF64 rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteF64.
        //
        // If rsLamda_UniffiForeignFutureCompleteF64 is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteF64 == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteF64(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteF64
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletef64
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteF64 != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteF64;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteF64 = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultF64 rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteF64(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteF64;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteF64 = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletef64
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletef64_UniffiForeignFutureCompleteF64_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompleterustbuffer_UniffiForeignFutureCompleteRustBuffer_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompleterustbuffer_UniffiForeignFutureCompleteRustBuffer_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompleterustbuffer::UniffiForeignFutureCompleteRustBuffer
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompleterustbuffer {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultRustBuffer)> rsLambda_UniffiForeignFutureCompleteRustBuffer = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteRustBuffer(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultRustBuffer rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultRustBuffer>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteRustBuffer: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteRustBuffer(uint64_t rs_callbackData, UniffiForeignFutureResultRustBuffer rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteRustBuffer.
        //
        // If rsLamda_UniffiForeignFutureCompleteRustBuffer is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteRustBuffer == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteRustBuffer(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteRustBuffer
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompleterustbuffer
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteRustBuffer != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteRustBuffer;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteRustBuffer = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultRustBuffer rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteRustBuffer(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteRustBuffer;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteRustBuffer = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompleterustbuffer
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompleterustbuffer_UniffiForeignFutureCompleteRustBuffer_DEFINED
#ifndef CALLBACK_uniffi_controller_cb_foreignfuturecompletevoid_UniffiForeignFutureCompleteVoid_DEFINED
#define CALLBACK_uniffi_controller_cb_foreignfuturecompletevoid_UniffiForeignFutureCompleteVoid_DEFINED
// Callback function: uniffi::controller::cb::foreignfuturecompletevoid::UniffiForeignFutureCompleteVoid
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::foreignfuturecompletevoid {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, UniffiForeignFutureResultVoid)> rsLambda_UniffiForeignFutureCompleteVoid = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiForeignFutureCompleteVoid(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_callbackData
            ,UniffiForeignFutureResultVoid rs_result) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_callbackData = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_callbackData);
        auto js_result = uniffi::controller::Bridging<UniffiForeignFutureResultVoid>::toJs(rt, callInvoker, rs_result);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_callbackData, js_result
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiForeignFutureCompleteVoid: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiForeignFutureCompleteVoid(uint64_t rs_callbackData, UniffiForeignFutureResultVoid rs_result) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiForeignFutureCompleteVoid.
        //
        // If rsLamda_UniffiForeignFutureCompleteVoid is null, then there is no runtime to call into.
        if (rsLambda_UniffiForeignFutureCompleteVoid == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiForeignFutureCompleteVoid(
            rs_callbackData, 
            rs_result);
    }

    [[maybe_unused]] static UniffiForeignFutureCompleteVoid
    makeCallbackFunction( // uniffi::controller::cb::foreignfuturecompletevoid
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiForeignFutureCompleteVoid != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiForeignFutureCompleteVoid;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiForeignFutureCompleteVoid = [rtPtr, callInvoker, callbackValue](uint64_t rs_callbackData, UniffiForeignFutureResultVoid rs_result) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_callbackData
                    , rs_result](jsi::Runtime &rt) mutable {
                    body_UniffiForeignFutureCompleteVoid(rt, callInvoker, callbackValue
                        , rs_callbackData
                        , rs_result);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiForeignFutureCompleteVoid;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiForeignFutureCompleteVoid = nullptr;
    }
} // namespace uniffi::controller::cb::foreignfuturecompletevoid
#endif // CALLBACK_uniffi_controller_cb_foreignfuturecompletevoid_UniffiForeignFutureCompleteVoid_DEFINED

// THIRD: Generate Bridging templates for ALL callbacks FIRST
// Structs will need these
#ifndef BRIDGING_UniffiRustFutureContinuationCallback_DEFINED
#define BRIDGING_UniffiRustFutureContinuationCallback_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiRustFutureContinuationCallbackWrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiRustFutureContinuationCallbackWrapper rsCallbackWrapper) {
    UniffiRustFutureContinuationCallback rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--RustFutureContinuationCallback"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiRustFutureContinuationCallback func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi_jsi::Bridging<int8_t>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiRustFutureContinuationCallback_DEFINED

#ifndef BRIDGING_UniffiForeignFutureDroppedCallback_DEFINED
#define BRIDGING_UniffiForeignFutureDroppedCallback_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureDroppedCallbackWrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureDroppedCallbackWrapper rsCallbackWrapper) {
    UniffiForeignFutureDroppedCallback rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureDroppedCallback"),
        1,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureDroppedCallback func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureDroppedCallback_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiCallbackInterfaceFree_DEFINED
#define BRIDGING_UniffiCallbackInterfaceFree_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiCallbackInterfaceFreeWrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiCallbackInterfaceFreeWrapper rsCallbackWrapper) {
    UniffiCallbackInterfaceFree rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--CallbackInterfaceFree"),
        1,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiCallbackInterfaceFree func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiCallbackInterfaceFree_DEFINED

#ifndef BRIDGING_UniffiCallbackInterfaceClone_DEFINED
#define BRIDGING_UniffiCallbackInterfaceClone_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiCallbackInterfaceCloneWrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiCallbackInterfaceCloneWrapper rsCallbackWrapper) {
    UniffiCallbackInterfaceClone rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--CallbackInterfaceClone"),
        1,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiCallbackInterfaceClone func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        auto value = func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0])
        );

        
        return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiCallbackInterfaceClone_DEFINED

#ifndef BRIDGING_UniffiForeignFutureCompleteU8_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteU8_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteU8Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteU8Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteU8 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU8"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteU8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultU8>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteU8_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteI8_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteI8_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteI8Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteI8Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteI8 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI8"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteI8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultI8>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteI8_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteU16_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteU16_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteU16Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteU16Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteU16 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU16"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteU16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultU16>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteU16_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteI16_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteI16_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteI16Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteI16Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteI16 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI16"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteI16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultI16>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteI16_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteU32_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteU32_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteU32Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteU32Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteU32 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU32"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteU32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultU32>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteU32_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteI32_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteI32_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteI32Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteI32Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteI32 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI32"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteI32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultI32>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteI32_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteU64_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteU64_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteU64Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteU64Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteU64 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU64"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteU64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultU64>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteU64_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteI64_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteI64_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteI64Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteI64Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteI64 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI64"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteI64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultI64>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteI64_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteF32_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteF32_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteF32Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteF32Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteF32 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF32"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteF32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultF32>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteF32_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteF64_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteF64_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteF64Wrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteF64Wrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteF64 rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF64"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteF64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultF64>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteF64_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteRustBuffer_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteRustBuffer_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteRustBufferWrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteRustBufferWrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteRustBuffer rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteRustBuffer"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteRustBuffer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultRustBuffer>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteRustBuffer_DEFINED

// CallbackFunction.cpp already generated in second loop
#ifndef BRIDGING_UniffiForeignFutureCompleteVoid_DEFINED
#define BRIDGING_UniffiForeignFutureCompleteVoid_DEFINED
namespace uniffi::controller {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper struct already declared in CallbackWrapperDecl.cpp

template <> struct Bridging<UniffiForeignFutureCompleteVoidWrapper> {
  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker, UniffiForeignFutureCompleteVoidWrapper rsCallbackWrapper) {
    UniffiForeignFutureCompleteVoid rsCallback = rsCallbackWrapper.callback;
    return jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteVoid"),
        2,
        [rsCallback, callInvoker](
            jsi::Runtime &rt,
            const jsi::Value &thisValue,
            const jsi::Value *arguments,
            size_t count) -> jsi::Value
        {
            return intoRust(rt, callInvoker, thisValue, arguments, count, rsCallback);
        }
    );
  }

  static jsi::Value intoRust(
      jsi::Runtime &rt,
      std::shared_ptr<CallInvoker> callInvoker,
      const jsi::Value &thisValue,
      const jsi::Value *args,
      size_t count,
      UniffiForeignFutureCompleteVoid func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
        func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<UniffiForeignFutureResultVoid>::fromJs(rt, callInvoker, args[1])
        );

        
        return jsi::Value::undefined();
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureCompleteVoid_DEFINED

// CallbackFunction.cpp already generated in second loop

// FOURTH: Generate Bridging templates for ALL structs
// These can now use both callback makeCallbackFunction AND callback Bridging templates
#ifndef BRIDGING_UniffiForeignFutureDroppedCallbackStruct_DEFINED
#define BRIDGING_UniffiForeignFutureDroppedCallbackStruct_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureDroppedCallbackStruct> {
  static UniffiForeignFutureDroppedCallbackStruct fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureDroppedCallbackStruct");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureDroppedCallbackStruct rsObject;

    // Create the vtable from the js callbacks.
    rsObject.handle = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "handle")
      );
    rsObject.free = uniffi::controller::cb::foreignfuturedroppedcallback::makeCallbackFunction(
          rt, callInvoker, jsObject.getProperty(rt, "free")
        );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureDroppedCallbackStruct &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "handle",
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rsValue.handle)
    );
    jsObject.setProperty(rt, "free",
      uniffi::controller::Bridging<UniffiForeignFutureDroppedCallbackWrapper>::toJs(rt, callInvoker, UniffiForeignFutureDroppedCallbackWrapper(rsValue.free))
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureDroppedCallbackStruct_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultU8_DEFINED
#define BRIDGING_UniffiForeignFutureResultU8_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultU8> {
  static UniffiForeignFutureResultU8 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultU8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint8_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU8 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultU8_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultI8_DEFINED
#define BRIDGING_UniffiForeignFutureResultI8_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultI8> {
  static UniffiForeignFutureResultI8 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultI8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int8_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI8 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultI8_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultU16_DEFINED
#define BRIDGING_UniffiForeignFutureResultU16_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultU16> {
  static UniffiForeignFutureResultU16 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultU16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint16_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU16 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultU16_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultI16_DEFINED
#define BRIDGING_UniffiForeignFutureResultI16_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultI16> {
  static UniffiForeignFutureResultI16 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultI16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int16_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI16 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<int16_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultI16_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultU32_DEFINED
#define BRIDGING_UniffiForeignFutureResultU32_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultU32> {
  static UniffiForeignFutureResultU32 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultU32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint32_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU32 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultU32_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultI32_DEFINED
#define BRIDGING_UniffiForeignFutureResultI32_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultI32> {
  static UniffiForeignFutureResultI32 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultI32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int32_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI32 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<int32_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultI32_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultU64_DEFINED
#define BRIDGING_UniffiForeignFutureResultU64_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultU64> {
  static UniffiForeignFutureResultU64 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultU64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultU64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultU64 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultU64_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultI64_DEFINED
#define BRIDGING_UniffiForeignFutureResultI64_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultI64> {
  static UniffiForeignFutureResultI64 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultI64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultI64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int64_t>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultI64 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<int64_t>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultI64_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultF32_DEFINED
#define BRIDGING_UniffiForeignFutureResultF32_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultF32> {
  static UniffiForeignFutureResultF32 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultF32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultF32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<float>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultF32 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<float>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultF32_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultF64_DEFINED
#define BRIDGING_UniffiForeignFutureResultF64_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultF64> {
  static UniffiForeignFutureResultF64 fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultF64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultF64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<double>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultF64 &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi_jsi::Bridging<double>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultF64_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultRustBuffer_DEFINED
#define BRIDGING_UniffiForeignFutureResultRustBuffer_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultRustBuffer> {
  static UniffiForeignFutureResultRustBuffer fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultRustBuffer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultRustBuffer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi::controller::Bridging<RustBuffer>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "returnValue")
      );
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultRustBuffer &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "returnValue",
      uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, rsValue.return_value)
    );
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultRustBuffer_DEFINED
#ifndef BRIDGING_UniffiForeignFutureResultVoid_DEFINED
#define BRIDGING_UniffiForeignFutureResultVoid_DEFINED
namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureResultVoid> {
  static UniffiForeignFutureResultVoid fromJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &jsValue
  ) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFutureResultVoid");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureResultVoid rsObject;

    // Create the vtable from the js callbacks.
    rsObject.call_status = uniffi::controller::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker,
        jsObject.getProperty(rt, "callStatus")
      );

    return rsObject;
  }

  static jsi::Value toJs(jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const UniffiForeignFutureResultVoid &rsValue
  ) {
    // Create a JS object
    auto jsObject = jsi::Object(rt);

    // Convert each field from Rust to JS
    jsObject.setProperty(rt, "callStatus",
      uniffi::controller::Bridging<RustCallStatus>::toJs(rt, callInvoker, rsValue.call_status)
    );

    return jsObject;
  }
};

} // namespace uniffi::controller
#endif // BRIDGING_UniffiForeignFutureResultVoid_DEFINED
    // Implementation of callback function calling from Rust to JS RustFutureContinuationCallback
#ifndef CALLBACK_uniffi_controller_cb_rustfuturecontinuationcallback_UniffiRustFutureContinuationCallback_DEFINED
#define CALLBACK_uniffi_controller_cb_rustfuturecontinuationcallback_UniffiRustFutureContinuationCallback_DEFINED
// Callback function: uniffi::controller::cb::rustfuturecontinuationcallback::UniffiRustFutureContinuationCallback
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::rustfuturecontinuationcallback {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<void(uint64_t, int8_t)> rsLambda_UniffiRustFutureContinuationCallback = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiRustFutureContinuationCallback(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_data
            ,int8_t rs_pollResult) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_data = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_data);
        auto js_pollResult = uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, rs_pollResult);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_data, js_pollResult
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiRustFutureContinuationCallback: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static void callback_UniffiRustFutureContinuationCallback(uint64_t rs_data, int8_t rs_pollResult) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiRustFutureContinuationCallback.
        //
        // If rsLamda_UniffiRustFutureContinuationCallback is null, then there is no runtime to call into.
        if (rsLambda_UniffiRustFutureContinuationCallback == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return;
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        rsLambda_UniffiRustFutureContinuationCallback(
            rs_data, 
            rs_pollResult);
    }

    [[maybe_unused]] static UniffiRustFutureContinuationCallback
    makeCallbackFunction( // uniffi::controller::cb::rustfuturecontinuationcallback
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiRustFutureContinuationCallback != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiRustFutureContinuationCallback;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiRustFutureContinuationCallback = [rtPtr, callInvoker, callbackValue](uint64_t rs_data, int8_t rs_pollResult) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_data
                    , rs_pollResult](jsi::Runtime &rt) mutable {
                    body_UniffiRustFutureContinuationCallback(rt, callInvoker, callbackValue
                        , rs_data
                        , rs_pollResult);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
        };
        return callback_UniffiRustFutureContinuationCallback;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiRustFutureContinuationCallback = nullptr;
    }
} // namespace uniffi::controller::cb::rustfuturecontinuationcallback
#endif // CALLBACK_uniffi_controller_cb_rustfuturecontinuationcallback_UniffiRustFutureContinuationCallback_DEFINED
    // JS-to-Rust callbacks already generated in first loop
    // Implementation of free callback function CallbackInterfaceFree

    // Implementation of callback function calling from Rust to JS CallbackInterfaceClone
#ifndef CALLBACK_uniffi_controller_cb_callbackinterfaceclone_UniffiCallbackInterfaceClone_DEFINED
#define CALLBACK_uniffi_controller_cb_callbackinterfaceclone_UniffiCallbackInterfaceClone_DEFINED
// Callback function: uniffi::controller::cb::callbackinterfaceclone::UniffiCallbackInterfaceClone
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback` function calls
// the lambda, which itself calls the `body` which then calls into JS.
//
// We then give the `callback` function pointer to Rust which will call the lambda sometime in the
// future.
namespace uniffi::controller::cb::callbackinterfaceclone {
    using namespace facebook;

    // We need to store a lambda in a global so we can call it from
    // a function pointer. The function pointer is passed to Rust.
    static std::function<uint64_t(uint64_t)> rsLambda_UniffiCallbackInterfaceClone = nullptr;

    // This is the main body of the callback. It's called from the lambda,
    // which itself is called from the callback function which is passed to Rust.
    static void body_UniffiCallbackInterfaceClone(jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     std::shared_ptr<jsi::Value> callbackValue
            ,uint64_t rs_handle) {

        // Convert the arguments from Rust, into jsi::Values.
        // We'll use the Bridging class to do this
        auto js_handle = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

        // Now we are ready to call the callback.
        // We are already on the JS thread, because this `body` function was
        // invoked from the CallInvoker.
        try {
            // Getting the callback function
            auto cb = callbackValue->asObject(rt).asFunction(rt);
            auto uniffiResult = cb.call(rt, js_handle
            );

            

            
        } catch (const jsi::JSError &error) {
            std::cout << "Error in callback UniffiCallbackInterfaceClone: "
                    << error.what() << std::endl;
            throw error;
        }
    }

    static uint64_t callback_UniffiCallbackInterfaceClone(uint64_t rs_handle) {
        // If the runtime has shutdown, then there is no point in trying to
        // call into Javascript. BUT how do we tell if the runtime has shutdown?
        //
        // Answer: the module destructor calls into callback `cleanup` method,
        // which nulls out the rsLamda_UniffiCallbackInterfaceClone.
        //
        // If rsLamda_UniffiCallbackInterfaceClone is null, then there is no runtime to call into.
        if (rsLambda_UniffiCallbackInterfaceClone == nullptr) {
            // This only occurs when destructors are calling into Rust free/drop,
            // which causes the JS callback to be dropped.
            return 0;  // Return zero for handle/uint64_t return types
        }

        // The runtime, the actual callback jsi::funtion, and the callInvoker
        // are all in the lambda.
        return rsLambda_UniffiCallbackInterfaceClone(
            rs_handle);
    }

    [[maybe_unused]] static UniffiCallbackInterfaceClone
    makeCallbackFunction( // uniffi::controller::cb::callbackinterfaceclone
                    jsi::Runtime &rt,
                     std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                     const jsi::Value &value) {
        if (rsLambda_UniffiCallbackInterfaceClone != nullptr) {
            // `makeCallbackFunction` is called in two circumstances:
            //
            // 1. at startup, when initializing callback interface vtables.
            // 2. when polling futures. This happens at least once per future that is
            //    exposed to Javascript. We know that this is always the same function,
            //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
            //
            // We can therefore return the callback function without making anything
            // new if we've been initialized already.
            return callback_UniffiCallbackInterfaceClone;
        }
        auto callbackFunction = value.asObject(rt).asFunction(rt);
        auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
        // Store a raw pointer to the runtime. This is safe because:
        // 1. The runtime is owned by React Native and persists for the app lifetime
        // 2. The cleanup() method is called when the runtime is destroyed, which nulls out rsLambda
        jsi::Runtime *rtPtr = &rt;
        rsLambda_UniffiCallbackInterfaceClone = [rtPtr, callInvoker, callbackValue](uint64_t rs_handle) {
                // We immediately make a lambda which will do the work of transforming the
                // arguments into JSI values and calling the callback.
                uniffi_runtime::UniffiCallFunc jsLambda = [
                    callInvoker,
                    callbackValue
                    , rs_handle](jsi::Runtime &rt) mutable {
                    body_UniffiCallbackInterfaceClone(rt, callInvoker, callbackValue
                        , rs_handle);
                };
                // We'll then call that lambda from the callInvoker which will
                // look after calling it on the correct thread.
                
                callInvoker->invokeNonBlocking(*rtPtr, jsLambda);
                return 0;  // Async callback, return immediately
        };
        return callback_UniffiCallbackInterfaceClone;
    }

    // This method is called from the destructor of NativeController, which only happens
    // when the jsi::Runtime is being destroyed.
    [[maybe_unused]] static void cleanup() {
        // The lambda holds a reference to the the Runtime, so when this is nulled out,
        // then the pointer will no longer be left dangling.
        rsLambda_UniffiCallbackInterfaceClone = nullptr;
    }
} // namespace uniffi::controller::cb::callbackinterfaceclone
#endif // CALLBACK_uniffi_controller_cb_callbackinterfaceclone_UniffiCallbackInterfaceClone_DEFINED
    // Structs already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop
    // Structs already generated in first loop
    // JS-to-Rust callbacks already generated in first loop


namespace uniffi::controller {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

// Wrapper to make this callback unique per module  
struct UniffiRustFutureContinuationCallbackControllerWrapper {
    UniffiRustFutureContinuationCallback callback;
    explicit UniffiRustFutureContinuationCallbackControllerWrapper(UniffiRustFutureContinuationCallback cb) : callback(cb) {}
    operator UniffiRustFutureContinuationCallback() const { return callback; }
};

template <> struct Bridging<UniffiRustFutureContinuationCallbackControllerWrapper> {
  static UniffiRustFutureContinuationCallbackControllerWrapper fromJs(
    jsi::Runtime &rt,
    std::shared_ptr<CallInvoker> callInvoker,
    const jsi::Value &value
  ) {
    try {
      return UniffiRustFutureContinuationCallbackControllerWrapper(
        uniffi::controller::cb::rustfuturecontinuationcallback::makeCallbackFunction(
          rt,
          callInvoker,
          value
        )
      );
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }
};

} // namespace uniffi::controller

NativeController::NativeController(
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> invoker
) : callInvoker(invoker), props() {
    // Map from Javascript names to the cpp names
    props["ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_clone_controlleraccount"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_clone_controlleraccount"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_clone_controlleraccount(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_free_controlleraccount"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_free_controlleraccount"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_free_controlleraccount(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_constructor_controlleraccount_new"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_constructor_controlleraccount_new"),
        7,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_constructor_controlleraccount_new(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless"),
        6,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_address"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_address"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_address(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_app_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_app_id"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_app_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_chain_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_chain_id"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_chain_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_disconnect"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_disconnect"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_disconnect(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_error_message"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_error_message"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_error_message(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_execute"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_execute"),
        2,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_execute(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_signup"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_signup"),
        4,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_signup(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain"),
        2,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_transfer"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_transfer"),
        3,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_transfer(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_username"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_controlleraccount_username"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_controlleraccount_username(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_clone_owner"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_clone_owner"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_clone_owner(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_free_owner"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_free_owner"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_free_owner(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_constructor_owner_new"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_constructor_owner_new"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_constructor_owner_new(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_clone_sessionaccount"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_clone_sessionaccount"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_clone_sessionaccount(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_free_sessionaccount"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_free_sessionaccount"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_free_sessionaccount(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe"),
        4,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_constructor_sessionaccount_new"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_constructor_sessionaccount_new"),
        7,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_constructor_sessionaccount_new(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_address"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_address"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_address(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_app_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_app_id"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_app_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_chain_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_chain_id"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_chain_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_execute"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_execute"),
        2,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_execute(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside"),
        2,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_expires_at"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_expires_at"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_expires_at(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_is_expired"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_is_expired"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_is_expired(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_session_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_session_id"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_session_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_username"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_method_sessionaccount_username"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_method_sessionaccount_username(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_func_controller_has_storage"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_func_controller_has_storage"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_func_controller_has_storage(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_func_get_controller_class_hash"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_func_get_controller_class_hash"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_func_get_controller_class_hash(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_func_get_public_key"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_func_get_public_key"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_func_get_public_key(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_func_signer_to_guid"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_func_signer_to_guid"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_func_signer_to_guid(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_fn_func_validate_felt"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_fn_func_validate_felt"),
        1,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_fn_func_validate_felt(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_func_controller_has_storage"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_func_controller_has_storage"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_func_controller_has_storage(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_func_get_controller_class_hash"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_func_get_controller_class_hash"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_func_get_controller_class_hash(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_func_get_public_key"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_func_get_public_key"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_func_get_public_key(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_func_signer_to_guid"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_func_signer_to_guid"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_func_signer_to_guid(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_func_validate_felt"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_func_validate_felt"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_func_validate_felt(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_address"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_address"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_address(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_app_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_app_id"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_app_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_error_message"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_error_message"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_error_message(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_execute"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_execute"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_execute(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_signup"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_signup"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_signup(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_transfer"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_transfer"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_transfer(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_username"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_controlleraccount_username"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_username(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_address"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_address"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_address(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_app_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_app_id"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_app_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_execute"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_execute"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_execute(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_session_id"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_session_id"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_session_id(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_username"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_method_sessionaccount_username"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_username(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_constructor_owner_new"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_constructor_owner_new"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_constructor_owner_new(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe(rt, thisVal, args, count);
        }
    );
    props["ubrn_uniffi_controller_uniffi_checksum_constructor_sessionaccount_new"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_uniffi_controller_uniffi_checksum_constructor_sessionaccount_new"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_controller_uniffi_checksum_constructor_sessionaccount_new(rt, thisVal, args, count);
        }
    );
    props["ubrn_ffi_controller_uniffi_uniffi_contract_version"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_ffi_controller_uniffi_uniffi_contract_version"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_controller_uniffi_uniffi_contract_version(rt, thisVal, args, count);
        }
    );
    props["ubrn_ffi_ControllerAccount__bless_pointer"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_ffi_ControllerAccount__bless_pointer"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_ControllerAccount__bless_pointer(rt, thisVal, args, count);
        }
    );
    props["ubrn_ffi_Owner__bless_pointer"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_ffi_Owner__bless_pointer"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_Owner__bless_pointer(rt, thisVal, args, count);
        }
    );
    props["ubrn_ffi_SessionAccount__bless_pointer"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "ubrn_ffi_SessionAccount__bless_pointer"),
        0,
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_SessionAccount__bless_pointer(rt, thisVal, args, count);
        }
    );
}

void NativeController::registerModule(jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
    auto invoker = std::make_shared<uniffi_runtime::UniffiCallInvoker>(callInvoker);
    auto tm = std::make_shared<NativeController>(rt, invoker);
    auto obj = rt.global().createFromHostObject(rt, tm);
    rt.global().setProperty(rt, "NativeController", obj);
}

void NativeController::unregisterModule(jsi::Runtime &rt) {
    uniffi::controller::registry::clearRegistry();
}

jsi::Value NativeController::get(jsi::Runtime& rt, const jsi::PropNameID& name) {
    try {
        return jsi::Value(rt, props.at(name.utf8(rt)));
    }
    catch (std::out_of_range &e) {
        return jsi::Value::undefined();
    }
}

std::vector<jsi::PropNameID> NativeController::getPropertyNames(jsi::Runtime& rt) {
    std::vector<jsi::PropNameID> rval;
    for (auto& [key, value] : props) {
        rval.push_back(jsi::PropNameID::forUtf8(rt, key));
    }
    return rval;
}

void NativeController::set(jsi::Runtime& rt, const jsi::PropNameID& name, const jsi::Value& value) {
    props.insert_or_assign(name.utf8(rt), &value);
}

NativeController::~NativeController() {
    // Cleanup for callback function RustFutureContinuationCallback
uniffi::controller::cb::rustfuturecontinuationcallback::cleanup();
    // Cleanup for "free" callback function CallbackInterfaceFree

    // Cleanup for callback function CallbackInterfaceClone
uniffi::controller::cb::callbackinterfaceclone::cleanup();
}

// Utility functions for serialization/deserialization of strings.
jsi::Value NativeController::cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
    return uniffi_jsi::Bridging<std::string>::string_to_bytelength(rt, args[0]);
}

jsi::Value NativeController::cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
    return uniffi_jsi::Bridging<std::string>::string_to_arraybuffer(rt, args[0]);
}

jsi::Value NativeController::cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
    return uniffi_jsi::Bridging<std::string>::arraybuffer_to_string(rt, args[0]);
}jsi::Value NativeController::cpp_ffi_ControllerAccount__bless_pointer(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
    auto pointer = uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
    auto static destructor = [](uint64_t p) {
        RustCallStatus status = {0};
        uniffi_controller_uniffi_fn_free_controlleraccount(p, &status);
    };
    auto ptrObj = std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
    auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
    return jsi::Value(rt, obj);
}jsi::Value NativeController::cpp_ffi_Owner__bless_pointer(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
    auto pointer = uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
    auto static destructor = [](uint64_t p) {
        RustCallStatus status = {0};
        uniffi_controller_uniffi_fn_free_owner(p, &status);
    };
    auto ptrObj = std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
    auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
    return jsi::Value(rt, obj);
}jsi::Value NativeController::cpp_ffi_SessionAccount__bless_pointer(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
    auto pointer = uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
    auto static destructor = [](uint64_t p) {
        RustCallStatus status = {0};
        uniffi_controller_uniffi_fn_free_sessionaccount(p, &status);
    };
    auto ptrObj = std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
    auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
    return jsi::Value(rt, obj);
}

// Methods calling directly into the uniffi generated C API of the Rust crate.
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_clone_controlleraccount(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_clone_controlleraccount(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_free_controlleraccount(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_free_controlleraccount(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_constructor_controlleraccount_from_storage(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_constructor_controlleraccount_new(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_constructor_controlleraccount_new(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]), uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[4]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[5]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[6]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_constructor_controlleraccount_new_headless(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]), uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[4]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[5]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_address(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_address(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_app_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_app_id(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_chain_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_chain_id(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_method_controlleraccount_clear_last_error(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_delegate_account(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_disconnect(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_method_controlleraccount_disconnect(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_error_message(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_error_message(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_execute(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_execute(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_signup(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_method_controlleraccount_signup(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_method_controlleraccount_switch_chain(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_transfer(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_transfer(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_controlleraccount_username(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_controlleraccount_username(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_clone_owner(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_clone_owner(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_free_owner(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_free_owner(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_constructor_owner_new(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_constructor_owner_new(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_clone_sessionaccount(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_clone_sessionaccount(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_free_sessionaccount(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        uniffi_controller_uniffi_fn_free_sessionaccount(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return jsi::Value::undefined();
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_constructor_sessionaccount_create_from_subscribe(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_constructor_sessionaccount_new(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_constructor_sessionaccount_new(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[4]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[5]), uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[6]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_address(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_address(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_app_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_app_id(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_chain_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_chain_id(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_execute(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_execute(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_execute_from_outside(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_expires_at(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_expires_at(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_is_expired(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_is_expired(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_is_revoked(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_owner_guid(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_session_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_session_id(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_method_sessionaccount_username(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_method_sessionaccount_username(uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_func_controller_has_storage(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_func_controller_has_storage(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_func_get_controller_class_hash(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_func_get_controller_class_hash(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_func_get_public_key(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_func_get_public_key(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_func_signer_to_guid(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_func_signer_to_guid(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi::controller::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_fn_func_validate_felt(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        RustCallStatus status = uniffi::controller::Bridging<RustCallStatus>::rustSuccess(rt);
        auto value = uniffi_controller_uniffi_fn_func_validate_felt(uniffi::controller::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]), 
            &status
        );
        uniffi::controller::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status, args[count - 1]);

        
        return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_func_controller_has_storage(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_func_controller_has_storage(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_func_get_controller_class_hash(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_func_get_controller_class_hash(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_func_get_public_key(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_func_get_public_key(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_func_signer_to_guid(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_func_signer_to_guid(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_func_validate_felt(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_func_validate_felt(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_address(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_address(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_app_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_app_id(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_chain_id(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_clear_last_error(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_delegate_account(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_disconnect(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_error_message(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_error_message(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_execute(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_execute(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_signup(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_signup(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_switch_chain(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_transfer(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_transfer(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_controlleraccount_username(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_controlleraccount_username(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_address(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_address(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_app_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_app_id(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_chain_id(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_execute(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_execute(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_execute_from_outside(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_expires_at(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_is_expired(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_is_revoked(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_owner_guid(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_session_id(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_session_id(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_method_sessionaccount_username(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_method_sessionaccount_username(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_constructor_controlleraccount_from_storage(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_constructor_controlleraccount_new(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_constructor_controlleraccount_new_headless(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_constructor_owner_new(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_constructor_owner_new(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_constructor_sessionaccount_create_from_subscribe(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_uniffi_controller_uniffi_checksum_constructor_sessionaccount_new(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = uniffi_controller_uniffi_checksum_constructor_sessionaccount_new(
        );

        
        return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeController::cpp_ffi_controller_uniffi_uniffi_contract_version(jsi::Runtime& rt, const jsi::Value& thisVal, const jsi::Value* args, size_t count) {
        auto value = ffi_controller_uniffi_uniffi_contract_version(
        );

        
        return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}